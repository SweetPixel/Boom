import System.Collections.Generic;#pragma strictenum eSlideDirection	{Up=0, Down, Right, Left}enum eSlideState		{Closed=0, Closing, Opening, Open}class crMenuItem	{	var	menuText			: String;	var	menuImage			: Texture;	var	menuAction			: String;}class crMenu  {	var MenuName 			: String;	var targetPos			: Rect;	var menuItems			: crMenuItem[];	var slideInDirection	: eSlideDirection	= eSlideDirection.Right;	var slideOutDirection	: eSlideDirection	= eSlideDirection.Right;	var	slideSpeed 			: float = 300.0f;@HideInInspector	var	alpha				: float;	private var	slideState	: eSlideState		= eSlideState.Closed;	private var	menuSkin	: GUISkin;	private var	curPos		: Rect;	private var	parent 		: GameObject;		function SetParent(to: GameObject)	{		parent = to;	}	function GetPos() : Rect	{		return curPos;	}	//set the menu to start at a proper offset to allow for smooth fading	function Hide()	{		switch(slideInDirection)		{			case eSlideDirection.Up		: curPos = Rect(targetPos.x,targetPos.y + targetPos.height,targetPos.width,targetPos.height); break;			case eSlideDirection.Down	: curPos = Rect(targetPos.x,targetPos.y - targetPos.height,targetPos.width,targetPos.height); break;			case eSlideDirection.Right	: curPos = Rect(targetPos.x - targetPos.width,targetPos.y,targetPos.width,targetPos.height); break;			case eSlideDirection.Left	: curPos = Rect(targetPos.x + targetPos.width,targetPos.y,targetPos.width,targetPos.height); break;		}	}	//make sure the various menus use the same skin as specified	function SetSkin(skn : GUISkin)	{		menuSkin = skn;	}		//start the process of fading in	function Activate()	{		if (slideState < eSlideState.Opening)			slideState = eSlideState.Opening;	}		//start the process of fading out	function Deactivate()	{		if (slideState > eSlideState.Closing)				slideState = eSlideState.Closing;	}		function DetermineAlpha()	{		var dist : float = 0;		var perc : float = 0;		//determine wether themenu is sliding in or out to determine which axis to use for alpha testing		var slideDirection : eSlideDirection = (slideState == eSlideState.Opening) ? slideInDirection : slideOutDirection;		switch (slideDirection)		{			case eSlideDirection.Up		:			case eSlideDirection.Down	:					dist = targetPos.y - curPos.y;					break;								case eSlideDirection.Right	: 			case eSlideDirection.Left	:					dist = targetPos.x - curPos.x;					break;		}				//speed up fading so the menu fades in half the tranvel distance		if (dist < 0) dist *= -1;		if (dist != 0)			dist *= 2;				//test the difference between current pos and target location		//target location being the position the menu should display at		//or the position right next to it, offset by exactly the size of the menu		//return the distance as a percentage and set alpha to that percentage		switch (slideDirection)		{			case eSlideDirection.Up:			case eSlideDirection.Down:				perc = 1 - (dist / targetPos.height);				break;			case eSlideDirection.Right:			case eSlideDirection.Left:				perc = 1 - (dist / targetPos.width);				break;		}				if (perc > 1) perc = 1;		if (perc < 0) perc = 0;		alpha = perc;	}		function Update ()	{		switch (slideState)		{						//if menu is opening: Update position, determine transparency and change state when done			case eSlideState.Opening: 				switch (slideInDirection)				{					case eSlideDirection.Up :						curPos.y -= slideSpeed * Time.deltaTime;						if (curPos.y <= targetPos.y)							curPos.y = targetPos.y;						break;					case eSlideDirection.Down :						curPos.y += slideSpeed * Time.deltaTime;						if (curPos.y >= targetPos.y)							curPos.y = targetPos.y;						break;					case eSlideDirection.Right :						curPos.x += slideSpeed * Time.deltaTime;						if (curPos.x >= targetPos.x)							curPos.x = targetPos.x;						break;					case eSlideDirection.Left :						curPos.x -= slideSpeed * Time.deltaTime;						if (curPos.x <= targetPos.x)							curPos.x = targetPos.x;						break;				}				DetermineAlpha();				if (alpha == 1)					slideState = eSlideState.Open;				break;										//if the menu is closing: update the position, determine transparency and change state when done			case eSlideState.Closing:				switch (slideOutDirection)				{					case eSlideDirection.Up :						curPos.y -= slideSpeed * Time.deltaTime;						break;					case eSlideDirection.Down :						curPos.y += slideSpeed * Time.deltaTime;						break;					case eSlideDirection.Right :						curPos.x += slideSpeed * Time.deltaTime;						break;					case eSlideDirection.Left :						curPos.x -= slideSpeed * Time.deltaTime;						break;				}				DetermineAlpha();				if (alpha == 0)				{					slideState = eSlideState.Closed;					Hide();				}				break;		}	}		function OnGUI()	{		//don't process anything if the menu is invisible		if (slideState == eSlideState.Closed) return; 		GUI.skin = menuSkin;		//get the current alpha value and assign it to the menu		var newcol = GUI.color;		newcol.a = alpha;		GUI.color = newcol;		//if the menu has items, show it		if (menuItems.Length > 0)		{			//adjust button size to fit the size allocated for the menu			//and show the menu items			var buttonHeight : float = (targetPos.height / menuItems.Length) ;			GUI.BeginGroup(curPos);				for (var x = 0; x < menuItems.Length; x++)				{					var selected = false;					//if the menu item has an image attached to it, use the image for the button					//otherwise show the text value of the menu item					if (menuItems[x].menuImage == null)						selected = GUI.Button(new Rect(0, x * (buttonHeight ), targetPos.width, buttonHeight), menuItems[x].menuText);					else						selected = GUI.Button(new Rect(0, x * (buttonHeight ), targetPos.width, buttonHeight), menuItems[x].menuImage);					if (selected)						parent.SendMessage("OnClicked", menuItems[x].menuAction);				}			GUI.EndGroup();		}	}}	var menuSkin					: GUISkin;									//The skin you want all menus to use	var Menus						: crMenu[];									//Configure all your menu pages		private var activeMenu			: crMenu;									//The menu to receive all input commands	private var deactivatingMenu	: crMenu;									//The menu that will fadde out	private var menuIsActive		: boolean	= true;							//Wether the menu system is active or disabled	private var menuPath			: System.Collections.Generic.List.<crMenu>;	//Traversed menu heirarchy so you can click on 'Back'	function isActive () : boolean	{		return menuIsActive;	}		function Start()	{		//store the menu navigation path so you can traverse back up the menu tree		menuPath = new System.Collections.Generic.List.<crMenu>();				//prepare the various menu items to work with the functions in this kit		for (var i = 0; i < Menus.Length; i++)		{			Menus[i].Hide();			Menus[i].SetSkin(menuSkin);			Menus[i].SetParent(gameObject);		}	}		function ShowMenu(named : String, addToPath: boolean) : boolean	{		if (named != "")		{			//see if the menu we want to display exists			for (var i =0; i < Menus.Length; i++)			{				if (Menus[i].MenuName == named)				{					//if a menu is already active, make it fade away					if (activeMenu != null)					{						deactivatingMenu = activeMenu;						activeMenu.Deactivate();						if (addToPath)							menuPath.Add(activeMenu);					}					//fade in the new menu					activeMenu = Menus[i];					activeMenu.Activate();					return true;				}			}		} else		// if menu to show is empty, deactivate all menus		{			menuPath.Clear();			if (activeMenu != null)			{				deactivatingMenu = activeMenu;				activeMenu.Deactivate();				activeMenu = null;			}		}		//if the code reached here then we can safely assume that a new menu was not loaded		//the only time the return value is checked is to determine wether a menu exists		//or not. so since it wasn't found, return false		return false;	}		//see if there are any menus fading in or out and update their positions	function Update()	{		if (activeMenu != null)			if (activeMenu.alpha < 1)				activeMenu.Update();					if (deactivatingMenu != null)			if (deactivatingMenu.alpha > 0)				deactivatingMenu.Update();	}		function OnGUI()	{		//only allow the menu to be navigated if you are still in the menu system		//once you enter an external screen from the menu, disable menu navigation		GUI.skin = menuSkin;		GUI.enabled = menuIsActive;				//show the currently selected menu		if (activeMenu != null)			activeMenu.OnGUI();					//also show the last active menu while it is fading out		if (deactivatingMenu != null)			deactivatingMenu.OnGUI();	}	//when a menu item is clicked, it sends the action to this function	//First check if there is a menu with that name and call it if there is	//or else assume it is a function call and pass that along to the game object...	function OnClicked(param: String)	{		if (!ShowMenu(param, true))		{			gameObject.SendMessage(param, SendMessageOptions.DontRequireReceiver);			ShowMenu("", false);			ActivateMenu(false);		}	}		function ActivateMenu(yesno : boolean)	{		menuIsActive = yesno;	}		function TraverseMenu()	{		//if I am in a submenu, no matter how many levels deep, clicking on the menu button		//acts as a "Back" button and goes to the menu one level up		if (menuPath.Count > 0)		{			var lastMenu : crMenu = menuPath[menuPath.Count-1];			menuPath.RemoveAt(menuPath.Count-1);			ShowMenu(lastMenu.MenuName, false);		} else		//if there is no menu currently active, show the first one in the list.		{			if (activeMenu != null)				ShowMenu("", false);			else				if (Menus != null)					if (Menus.Length > 0)						ShowMenu(Menus[0].MenuName, true);		}	}